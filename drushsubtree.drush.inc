<?php
require_once('drushsubtree.subtreecommander.class.inc');
/**
 * @file
 * drushsubtree drush command.
 *
 *  You can copy this file to any of the following
 *    1. A .drush folder in your HOME folder.
 *    2. Anywhere in a folder tree below an active module on your site.
 *    3. /usr/share/drush/commands (configurable)
 *    4. In an arbitrary folder specified with the --include option.
 *    5. Drupal's /drush or /sites/all/drush folders.
 */

/**
 * Implements hook_drush_command().
 */
function drushsubtree_drush_command() {
  $items = array();

  $items['drushsubtree-add'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Subtree defined in buildmanager config.',
    ),
    'options' => array(
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
      'message' => array(
        'description' => 'Message to include at the beginning of new commits.',
      ),
    ),
    'examples' => array(
      'drush subtree-add' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
    'aliases' => array('subtree-add'),
  );

  $items['drushsubtree-pull'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Subtree defined in buildmanager config.',
    ),
    'options' => array(
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
      'message' => array(
        'description' => 'Message to include at the beginning of new commits.',
      ),
    ),
    'examples' => array(
      'drush subtree-pull' => '',
    ),
    'aliases' => array('subtree-pull'),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-merge'] = array(
    'description' => '',
    'arguments' => array(
      'project' => '(Optional) Subtree defined in buildmanager config.',
    ),
    'options' => array(
      'simulate' => array(
        'description' => 'Output commands to be executed for examination, but do not actually execute them.',
      ),
      'message' => array(
        'description' => 'Message to include at the beginning of new commits.',
      ),
    ),
    'examples' => array(
      'drush subtree-merge' => '',
    ),
    'aliases' => array('subtree-merge'),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

  $items['drushsubtree-push'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(
      'drush subtree-push' => '',
    ),
    'aliases' => array('subtree-push'),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );

 /*
  $items['drushsubtree-checkout'] = array(
    'description' => '',
    'arguments' => array(),
    'examples' => array(),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );
  // */

  $items['drushsubtree-get-tags'] = array(
    'description' => "Get a list of tagged releases for a subtree project.",
    'arguments' => array(
      'project_name' => '',
      'config' => '(Optional) path/to/drushsubtree.config.yml',
    ),
    'examples' => array(
      'drush drushsubtree-get-tags my_project' => '',
    ),
    // No bootstrap at all.
    'bootstrap' => DRUSH_BOOTSTRAP_DRUSH,
  );
  $items['drushsubtree-setup-repo'] = array(
    // TODO
    // Prompt:
    // - Create symlink-these directory
    // - Create/Symlink sites directory/-ies.
    // - Create/Symlink .htaccess
    // - Create/Symlink robots.txt
    // - Create mysite.config.inc
    // - Symlink build/make files
    // If site is an instance of a distro with tests:
    // - Symlink behat/travis/etc files generated by cpliakas's drupal-distro
    // - Create testsite.config.inc (if used in build.xml)
  );

  return $items;
}

/**
 * Implements hook_drush_help().
 */
function site_make_drush_help($section) {
  switch ($section) {
    case 'drush:site-make':
      return dt("@todo");

  }
}

/**
 * Callback for drushsubtree-get-tags().
 */
function drush_drushsubtree_get_tags($subtree_name, $config_file = '') {
  // Get config_file.
  $config = _drushsubtree_get_config($config_file);
  if (!$details = $config['subtrees'][$subtree_name]) {
    drush_set_error(dt('No subtree config available for !subtree in !config_file'),
      array('!subtree' => $subtree_name, '!config_file' => $config_file));
  }

  // Look up tags from remote specified in $details.
  $tags = drushsubtree_list_remote_tags($subtree_name, $details);

  foreach ($tags as $tag => $id) {
    drush_print("{$tag}\t{$id}");
  }
}


/**
 * Get message to be included with subtree add/pull/merge commits.
 *
 * Site make config files can specify a message to be included
 * project-by-project.
 *
 * @param string $message
 *   Defined in buildmanager YAML config file.
 *
 * @return string
 *   A commit message flag to a git subtree add, pull, or merge command.
 *   Empty string if no message should be added.
 */
function _drushsubtree_add_subtree_commit_message($subtree_message = '') {
  $drush_message = drush_get_option('message', '');
  if ($drush_message || $subtree_message) {
    $custom_message = ($drush_message) ? "{$drush_message}\n\n\t{$subtree_message}" : $subtree_message;
  }
  $message = ($custom_message) ? " --message='{$custom_message}'" : '';

  return $message;
}

/**
 * Get prefix (path) to local subtree.
 *
 * @param string $directory
 *   Name of directory where subtree should go.
 *
 * @return string
 *   Path to subtree from top-level of repo to be used for --prefix.
 */
function _drushsubtree_get_prefix($directory) {
  return "projects/{$directory}";
}

/**
 * Get URI for remote git repo.
 *
 * @param array $details
 *   Relevant details for git subtree add command.
 *
 * @return string|bool
 *   Uri for git repo.
 */
function _drushsubtree_get_uri($details) {
  if (!(isset($details['uri']) || !strlen($details['uri']) > 0)) {
    return drush_set_error('drushsubtree', dt("uri is a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }
  else {
    return $details['uri'];
  }
}

/**
 * Get subtree branch from drushsubtree project details included in config file.
 *
 * @param array $details
 *   Relevant details for git subtree add command:
 *
 * @return string|bool
 *   Branch name.
 */
function _drushsubtree_get_branch($details) {
  if (!(isset($details['branch']) || !strlen($details['branch']) > 0)) {
    return drush_set_error('drushsubtree', dt("branchis a required subtree parameter for any subtree included here. Please add this to your site's config file, then try again."), 'error');
  }

  return $details['branch'];
}
/**
 * Figure out what version of a subtree project should be checked out.
 *
 * Return commit ID so "checkout" can be done as a subtree merge.
 *
 * @param string $subtree_name
 *   Name of subtree.
 *
 * @param array $info
 *   Info from parsed make files.
 *
 * @param array $details
 *   Details about subtree project from buildmanager config.
 *
 * @param string $tag
 *   Tag, if available. Empty if not.
 *
 * @return string
 *   Commit ID for subtree to be merged to. Empty if unavailable.
 */
function _drushsubtree_get_project_id($subtree_name, $info, $details, $tag) {
  $id = '';

  // First, try getting ID ("revision") from make files.
  $project_info = (isset($info['projects'][$subtree_name])) ? $info['projects'][$subtree_name] : array();
  $id = _drushsubtree_get_id_from_make_info($subtree_name, $project_info);

  // If no commit ID was specified in make file(s),  try looking up using remote
  // list of tags.
  $tags = drushsubtree_list_remote_tags($subtree_name, $details);
  if (!$tags) {
    // Attempt to retrieved tags from remote failed.
    drush_log(dt("Commit IDs for !name tags could not be retrieved from !remote.\nTo explicitly designate which commit ID to check out for version !tag, you can add this to your makefile (replace abc1234 with a real commit ID):\n\tprojects[!name][download][revision] = abc1234",
      array('!name' => $subtree_name, '!remote' => $details['uri'],
            '!tag' => $tag)), 'warning');
  }
  if ($tag && $tags) {
    // Success!
    $id = $tags[$tag];
  }
 
  return $id;
}

/**
 * Get a commit ID ("revision") from a drush make file info.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string|bool
 *   Project revision (commit) id specified in make file. False if unavailable.
 */
function _drushsubtree_get_id_from_make_info($project_name, $project_info) {
  $id = (isset($project_info['download']['revision'])) ? $project_info['download']['revision'] : FALSE;
  return $id;
}

/**
 * Retrieve list of tags and corresponding commit IDs from remote repository.
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $details
 *   From drushsubtree config.
 *
 * @return array|bool
 *   Commit IDs keyed by tag name. False for failure.
 */
function drushsubtree_list_remote_tags($project_name, $details) {
  // Get a list of commit IDs and corresponding tags. A successful request
  // returns something like this:
  // 516726690a5f3a15ccf8d7ffccd135db4375ad10  refs/tags/7.x-1.0-rc1
  // e214ea5b94f345b66f302d0d4aae232b4128c1e3  refs/tags/7.x-1.0-rc2
  // 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0-rc3
  $command = "git ls-remote --tags {$details['uri']}";

  // Each line of output is stored in $output array.
  // $exit_code is 0 for success, anything else for failure.
  exec($command, $output, $exit_code);

  // Handle failure.
  if ($exit_code !== 0) {
    return drush_set_error('drushsubtree', dt("Request for remote tag list failed: !command", array('!command' => $command)));
  }

  // Parse result.
  $tags = array();
  foreach ($output as $line) {
    // Example line: 8f61c66e5f55e72a35f4a1b8f4eee93a428a03ac  refs/tags/7.x-1.0
    $parts = explode("\t", $line);
    if (count($parts) < 2) {
      // Skip empty lines that sneak in.
      continue;
    }
    $pos = strlen('refs/tags/');
    $tag = substr($parts[1], $pos);
    $id = $parts[0];
    $tags[$tag] = $id;
  }

  return $tags;
}

/**
 * Get tag/version for a project specified in make file(s).
 *
 * @param string $project_name
 *   Name of project (module, profile, theme, library).
 *
 * @param array $project_info
 *   Project info array from make files.
 *
 * @return string
 *   Project version number specified in make file. Empty if unavailable.
 */
function _drushsubtree_get_project_tag($project_name, $project_info) {
  $tag = '';

  if (isset($project_info['version'])) {
    $tag = $project_info['version'];
  }
  elseif (isset($project_info['download']['tag'])) {
    $tag = $project_info['download']['tag'];
  }
  else {
    // Make files do not specify any tag for this project.
    drush_log(dt("No tag or commit ID available for !name.",
                  array('!name' => $project_name), 'warning'));
  }

  return $tag;
}

/**
 * Return command to generate symlink to subtree.
 *
 * This command must be run from top-level of repo.
 *
 * @param string $name
 *   Name of project (module, theme, profile) to be replaced with a symlink to a
 *   subtree inside /projects.
 *
 * @param string $path
 *   Path to project in Drupal code base, relative to top-level of site repo.
 *
 * @return string
 *   Shell command for adding symlink.
 */
function _drushsubtree_subtree_add_symlink($name, $path) {
  // Get path to subtree, relative to top-level directory.
  $prefix = _drushsubtree_get_prefix($name);

  // Get source, relative to parent directory inside docroot.
  $count = count(explode('/', $path));
  $source = '';
  for ($i = 0; $i < $count - 1; $i++) {
    $source .= '../';
  };
  // Add prefix to relative source path.
  $source .= $prefix;

  // Parent directory for symlink.
  $pos = strpos($path, $name);
  $parent_directory = substr($path, 0, $pos);

  // Remove the directory. Replace it with a symlink.
  $command = "rm -rf {$path}; cd {$parent_directory}; ln -s {$source} {$name};";

  return $command;
}

/**
 * Implements hook_buildmanager_build().
 *
 * Check for subtrees in config file. Add/update subtrees in build as appropriate.
 *
 * @param array $info
 *   Info from drush make build file.
 *
 * @param array $config
 *   Configuration defined in buildmanager.config.yml
 *
 * @param obj $commands
 *   Commands to be executed by buildmanager.
 *   - precommands (array), commands to execute before `drush make` (re)build
 *   - postcommands (array), commands to execute after `drush make` (re)build
 */
function drushsubtree_buildmanager_build($info, $config, $commands) {
  // Check for subtrees in $config.
  if (!isset($config['subtrees'])) {
    // This project has no subtrees. Our work here is done.
    return;
  }

  // @todo Check if there are uncommitted changes locally. Exit if there are.
  // Otherwise, subtree add/pull won't work.
  // If there are subtrees in the config file, get commands for adding/updating
  // subtrees.

  drush_log(dt('Preparing to add/update git subtrees.'), 'ok');

  // Prep projects directory. All subtrees will use --prefix=projects/$name
  _drushsubtree_prep_projects_directory();

  // Get subtree commands to be executed before running `drush make`.
  $subtree_commands = array();

  // Get symlink commands to be run after `drush make`.
  $symlink_commands = array();

  // Loop through subtrees twice. Repo updates should be done as prebuild commands.
  // Symlinks (which will get blown away by drush make) should be restored as
  // postbuild commands.
  foreach ($config['subtrees'] as $subtree_name => $details) {

    // Start with postbuild commands (adding symlinks) because prebuild commands
    // are sometimes skipped (when no-subtree-updates flag is set).
    // Remove files checked out by drush. Add symlink pointing to local subtree.
    drush_log(dt('Preparing to symlink !subtree_name to path: !path', array('!subtree_name' => $subtree_name, '!path' => $details['path'])), 'ok');
    $symlink_commands[] = _drushsubtree_subtree_add_symlink($subtree_name,
                                                          $details['path']);

    // Next add do prebuild commands / subtree repo updates.
    if (drush_get_option('no-subtree-updates', FALSE)) {
      // If no-subtree-updates flag is set, skip the rest of the foreach loop.
      drush_log(dt('Skipping git subtree updates.'), 'ok');
      continue;
    }

    // Instantiate new commander to generate subtree commands.
    $subtree = new SubtreeCommander($subtree_name, $details);

    // Collect commands as $subtree_commands, then add them all to the
    // beguinning of $commands->prebuild array.
    // It's important these run before drush make for
    // two reasons: (1) Incase a project's build file includes a make file in a
    // subtree project. This will ensure the updated make file is included in the
    // build. (2) This needs to run before anything else dirties the working
    // tree (like drush make), otherwise the subtree add/pull/merge will fail.
    // First, add git subtree if it doesn't already exist.
    if ($subtree_add = $subtree->add()) {
      drush_log(dt('Preparing to add subtree: !subtree_name', array('!subtree_name' => $subtree_name)), 'ok');
      $subtree_commands[] = $subtree_add;
    }
    // Otherwise, pull in any updates.
    //elseif ($subtree_pull = _drushsubtree_subtree_pull($subtree_name, $details)) {
    elseif ($subtree_pull = $subtree->pull()) {
      $subtree_commands[] = $subtree_pull;
    }

    // Use git subtree merge to check out a particular version of a project.
    // First get the git commit ID to merge to using info from make files.
    $tag = _drushsubtree_get_project_tag($subtree_name,
                                         $info['projects'][$subtree_name]);
    $id = _drushsubtree_get_project_id($subtree_name, $info, $details, $tag);
    if ($id) {
      $subtree_commands[] = $subtree->merge($id, $tag);
    }
    else {
      // @todo Detect latest recommended release on d.o when no version is
      // specified. Consider checking that out to better match standard make file
      // behavior?
      drush_log(dt("No commit ID specified for !project (if a tag was specified in a make file, the cooresponding commit ID could not be retrieved). Your install will run on the tip of whatever branch you checked out. (Subtrees do not fallback to the latest recommended release on drupal.org when no version is specified.)", array('!project' => $subtree_name)), 'warning');
    }

  // End loop thorugh subtrees.
  }

  // Add symlink commands after drush make but before other commands, incase any
  // custom post-build commands are committing anything. This way, git history
  // doesn't get polluted with projects being re-added and re-removed every time.
  $commands->postbuild = array_merge($symlink_commands, $commands->postbuild);

  // Now add all subtree_commands to begining of prebuild command list.
  $commands->prebuild = array_merge($subtree_commands, $commands->prebuild);

  // No return necessary. Commands added to $command object are available to
  // buildmaster_build command now.
}

/**
 * Prep projects directory.
 */
function _drushsubtree_prep_projects_directory() {
  // Before adding/pulling subtrees, make sure parent directory
  // for --prefix exists.
  if (!file_exists('projects')) {
    $success = mkdir('projects', 0777, TRUE);
    if (!$success) {
      return drush_set_error('buildmanager', dt("Failed creating directory: projects"), 'error');
    }
  }
  elseif (file_exists('projects') && !is_dir('projects')) {
    return drush_set_error('buildmanager', dt("Please remove the 'projects' file. We need to create a directory with that name for your subtrees."), 'error');
  }

  if ($success) {
    drush_log(dt('A projects directory has been created at the top of your git repo. Git subtrees will be added there.'), 'ok');
  }
}

/**
 * Implements hook_buildmanager_build_options();
 */
function drushsubtree_buildmanager_build_options() {
  return array(
    'no-subtree-updates' => array(
      'description' => 'Do add/pull/merge subtrees in buildmanager config.',
    ),
    // @todo
    're-add' => array(
      'description' => '@todo Remove and re-add comma separated list of subtree(s).',
    ),
  );  
}

/**
 * Callback for drushsubtree-add (subtree-add).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_add($name = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drush_subtree_get_name($config);
  }

  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  drush_shell_exec($subtree->add());
}

/**
 * Find, parse, return buildmanager config.
 *
 * @param string $conf_file
 *   Optional /path/to/buildmanager.config.yml.
 *
 * @return array
 *   Parsed buildmanager.config.yml.
 */
function _drushsubtree_get_config($config_file = '') {
  if (!function_exists('buildmanager_get_config_file')) {
    return drush_set_error('drushsubtree', dt('Missing Drush dependency: Build Manager'));  
  }
  if (!$config_file) {
    $config_file = buildmanager_get_config_file();
  }
  $config = _buildmanager_get_config($config_file);

  return $config; 
}

// TODO
function drush_drushsubtree_checkout($project) {}

/**
 * Callback for drushsubtree-pull (subtree-pull).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_pull($name = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drush_subtree_get_name($config);
  }

  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  drush_shell_exec($subtree->pull());
}

/**
 * Callback for drushsubtree-merge (subtree-merge).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_merge($name = '') {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drush_subtree_get_name($config);
  }

  // Get project info from make file(s).
  $project_info = buildmanager_get_project_info($name, $config);

  // Get git tag and id.
  $properties = $config['subtrees'][$name];
  $tag = _drushsubtree_get_project_tag($name, $project_info);
  $id = _drushsubtree_get_project_id($name, $info, $properties, $tag);

  $subtree = new SubtreeCommander($name, $properties);
  drush_shell_exec($subtree->merge($id, $tag));
}

/**
 * Callback for drushsubtree-push (subtree-push).
 *
 * @param string $name
 *   Name of subtree.
 */
function drush_drushsubtree_push($name) {
  // Get buildmanager config.
  $config = _drushsubtree_get_config();

  // Get name if not passed as argument.
  if (!$name) {
    $name = _drush_subtree_get_name($config);
  }

  $properties = $config['subtrees'][$name];
  $subtree = new SubtreeCommander($name, $properties);
  drush_shell_exec($subtree->push());
}

/**
 * Prompt user to select subtree from options in config file.
 *
 * TODO If only one, use that, no prompt. Notify user decision has been made.
 *
 * @param array $config
 *   Parsed config from buildmanager config file.
 *
 * @return string
 *   Name of subtree
 */
function _drush_subtree_get_name($config) {
  $names = array_keys($config['subtrees']);
  $names = array_combine($names, $names);
  $name = drush_choice($names, dt('Select a subtree to pull:'));
  return $name; 
}
